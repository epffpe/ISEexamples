                        ;KCPSM3 Program - Monitor for Spartan-3 Starter Board.
                        ;
                        ;Ken Chapman - Xilinx Ltd - February 2004
                        ;
                        ;----------------------------------------------------------------------------------
                        ;
                        ; NOTICE:
                        ;
                        ; Copyright Xilinx, Inc. 2004.   This code may be contain portions patented by other
                        ; third parties.  By providing this core as one possible implementation of a standard,
                        ; Xilinx is making no representation that the provided implementation of this standard
                        ; is free from any claims of infringement by any third party.  Xilinx expressly
                        ; disclaims any warranty with respect to the adequacy of the implementation, including
                        ; but not limited to any warranty or representation that the implementation is free
                        ; from claims of any third party.  Furthermore, Xilinx is providing this core as a
                        ; courtesy to you and suggests that you contact all third parties to obtain the
                        ; necessary rights to use this implementation.
                        ;
                        ;----------------------------------------------------------------------------------
                        ;
                        ;Port definitions
                        ;
                        CONSTANT UART_status_port, 00            ;UART status input (shared with PROM status)
                        CONSTANT tx_half_full, 01                ;  Transmitter     half full - bit0
                        CONSTANT tx_full, 02                     ;    FIFO               full - bit1
                        CONSTANT rx_half_full, 04                ;  Receiver        half full - bit2
                        CONSTANT rx_full, 08                     ;    FIFO               full - bit3
                        CONSTANT rx_data_present, 10             ;               data present - bit4
                        ;
                        ;
                        CONSTANT PROM_status_port, 00            ;PROM reader status input (shared with UART status)
                        CONSTANT PROM_sync, 40                   ;  Sync pattern found - bit6
                        CONSTANT PROM_data_ready, 20             ;  Data ready to read - bit5
                        ;
                        CONSTANT PROM_data_port, 05              ;Serial PROM data input
                        ;
                        CONSTANT PROM_reset_port, 40             ;Reset of serial PROM reader (bit 0)
                        ;
                        CONSTANT UART_read_port, 01              ;UART Rx data input
                        ;
                        CONSTANT UART_write_port, C0             ;UART Tx data output
                        ;
                        CONSTANT LED_port, A0                    ;8 simple LEDs
                        ;
                        CONSTANT switch_port, 02                 ;8 simple switches
                        ;
                        CONSTANT button_port, 03                 ;4 simple switches (bits 0 to 3)
                        ;
                        ;16 byte read/write memory from address E0 to EF
                        ;of which lower 4 addresses map to 7-segment display
                        ;
                        CONSTANT digit0_RAM, E0                  ;7-segment display digit 0
                        CONSTANT digit1_RAM, E1                  ;7-segment display digit 1
                        CONSTANT digit2_RAM, E2                  ;7-segment display digit 2
                        CONSTANT digit3_RAM, E3                  ;7-segment display digit 3
                        ;
                        ;SRAM address is 18-bits and requires 3 output ports 11, 12 and 14
                        ;
                        CONSTANT lower_RAM_adddress, 11          ;bits 0 to 7
                        CONSTANT middle_RAM_adddress, 12         ;bits 8 to 15
                        CONSTANT upper_RAM_adddress, 14          ;bits 16 to 17 (map to bits 0 to 1)
                        ;
                        ;SRAM control port
                        ;
                        CONSTANT SRAM_control_port, 80
                        CONSTANT SRAM_ram_we, 80                 ;bits 7 - write enable for both RAMs
                        CONSTANT SRAM_ram_oe, 40                 ;bits 6 - output enable for both RAMs
                        CONSTANT SRAM_ram_a_ce, 20               ;bits 5 - chip enable for RAM 'A'
                        CONSTANT SRAM_ram_a_ub, 10               ;bits 4 - upper byte select for RAM 'A'
                        CONSTANT SRAM_ram_a_lb, 08               ;bits 3 - lower byte select for RAM 'A'
                        CONSTANT SRAM_ram_b_ce, 04               ;bits 5 - chip enable for RAM 'B'
                        CONSTANT SRAM_ram_b_ub, 02               ;bits 4 - upper byte select for RAM 'B'
                        CONSTANT SRAM_ram_b_lb, 01               ;bits 3 - lower byte select for RAM 'B'
                        ;
                        ;SRAM data output
                        ;
                        CONSTANT SRAM_data_out_port, 60
                        ;
                        ;SRAM data input
                        ;
                        CONSTANT SRAM_data_in_port, 04
                        ;
                        ;
                        ;Special Register usage
                        ;
                        NAMEREG sF, UART_data                    ;used to pass data to and from the UART
                        ;
                        NAMEREG sE, store_pointer                ;used to pass location of data in scratch pad memory
                        ;
                        ;Two registers to form a 16-bit counter used to count
                        ;interrupt pulses generated at 1us intervals.
                        ;
                        NAMEREG sD, int_counter_lsb              ;lower 8-bits
                        NAMEREG sC, int_counter_msb              ;upper 8-bits
                        ;
                        ;
                        ;Scratch Pad Memory Locations
                        ;
                        ;
                        CONSTANT us_time_stamp_lsb, 00           ;16-bit micro-second time stamp
                        CONSTANT us_time_stamp_msb, 01
                        ;
                        CONSTANT us_time_lsb, 02                 ;16-bit micro-second real time value
                        CONSTANT us_time_msb, 03
                        ;
                        CONSTANT ms_time_lsb, 04                 ;16-bit milli-second real time value
                        CONSTANT ms_time_msb, 05
                        ;
                        CONSTANT real_time_hours, 06             ;Current clock time
                        CONSTANT real_time_minutes, 07
                        CONSTANT real_time_seconds, 08
                        ;
                        CONSTANT alarm_time_hours, 09            ;Alarm time
                        CONSTANT alarm_time_minutes, 0A
                        CONSTANT alarm_time_seconds, 0B
                        ;
                        CONSTANT alarm_status, 0C                ;Alarm status
                        CONSTANT alarm_active, 01                ;    bit0 - Alarm is active
                        CONSTANT alarm_armed, 02                 ;    bit1 - Alarm is armed
                        ;
                        CONSTANT time_preserve0, 10              ;storage for protection of registers
                        CONSTANT time_preserve1, 11              ;used by the real time clock routine.
                        CONSTANT time_preserve2, 12
                        CONSTANT time_preserve3, 13
                        CONSTANT time_preserve4, 14
                        CONSTANT time_preserve5, 15
                        ;
                        CONSTANT LED_status, 0D                  ;Status of the 8 simple LEDs
                        ;
                        ;UART character strings will be stored in scratch pad memory ending in carriage return.
                        ;A string can be up to 16 characters with the start location defined by this constant.
                        ;
                        CONSTANT string_start, 30
                        ;
                        ;
                        ;Initialise the system
                        ;
                        ;
            cold_start: LOAD s0, FF                              ;SRAM memory controls safe
                        OUTPUT s0, SRAM_control_port
                        LOAD s0, 00                              ;clear all time values except hours
                        STORE s0, us_time_stamp_lsb
                        STORE s0, us_time_stamp_msb
                        STORE s0, us_time_lsb
                        STORE s0, us_time_msb
                        STORE s0, ms_time_lsb
                        STORE s0, ms_time_msb
                        STORE s0, real_time_hours
                        STORE s0, real_time_minutes
                        STORE s0, real_time_seconds
                        STORE s0, alarm_time_hours
                        STORE s0, alarm_time_minutes
                        STORE s0, alarm_time_seconds
                        STORE s0, alarm_status                   ;clear and disable alarm
                        STORE s0, LED_status                     ;turn off all LEDs
                        CALL drive_LEDs
                        LOAD s0, 0C                              ;Start with 12:00 hours
                        STORE s0, real_time_hours
                        LOAD int_counter_lsb, 00                 ;clear 'us' interrupt counter
                        LOAD int_counter_msb, 00
                        ENABLE INTERRUPT                         ;enable the 1us interrupts
                        ;
                        ;
                        ;Start of the main program loop.
                        ;
                        ;A prompt is transmitted to the UART transmitter and then
                        ;a command can be entered and interpreted.
                        ;
                        ;
          prompt_input: CALL send_prompt                         ;Prompt 'KCPSM3>'
                        CALL receive_string                      ;obtain input string and maintain the time
                        ;
                        ;
                        ;Parse the string and perform actions as required
                        ;
                        ;
                        ;
                        LOAD s1, string_start
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return does nothing
                        JUMP Z, prompt_input
                        COMPARE s0, character_T                  ;start of 'TIME' command?
                        JUMP Z, test_for_TIME
                        COMPARE s0, character_A                  ;start of 'ALARM' command?
                        JUMP Z, test_for_ALARM
                        COMPARE s0, character_L                  ;start of 'LED' command?
                        JUMP Z, test_for_LED
                        COMPARE s0, character_S                  ;start of 'SWITCH' command?
                        JUMP Z, test_for_SWITCH
                        COMPARE s0, character_B                  ;start of 'BUTTON' command?
                        JUMP Z, test_for_BUTTON
                        COMPARE s0, character_P                  ;start of 'PROM' command?
                        JUMP Z, test_for_PROM
                        COMPARE s0, character_R                  ;start of 'R' command?
                        JUMP Z, test_for_Read
                        COMPARE s0, character_W                  ;start of 'W' command?
                        JUMP Z, test_for_Write
                        ;
                        ;trap other command starts here
                        ;
     bad_input_command: CALL send_Syntax_Error                   ;no valid command
                        JUMP prompt_input
                        ;
                        ;
                        ;
                        ;
                        ;
        test_for_Write: CALL read_RAM_letter                     ;test for RAM letter and space
                        COMPARE sA, 00                           ;check for invalid RAM letter and space
                        JUMP Z, bad_RAM
                        CALL set_RAM_address                     ;read and set address in range 00000 to 3FFFF
                        JUMP C, bad_address
                        CALL fetch_char_from_memory
                        COMPARE s0, character_space              ;space separator between address and data
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory              ;read next 2 characters (data upper byte)
                        LOAD s3, s0
                        CALL fetch_char_from_memory
                        LOAD s2, s0
                        CALL ASCII_byte_to_hex                   ;convert to hex in range 00 to FF
                        JUMP C, bad_data
                        LOAD s6, s0                              ;remember upper byte
                        CALL fetch_char_from_memory              ;read next 2 characters (data lower byte)
                        LOAD s3, s0
                        CALL fetch_char_from_memory
                        LOAD s2, s0
                        CALL ASCII_byte_to_hex                   ;convert to hex in range 00 to FF
                        JUMP C, bad_data
                        LOAD s5, s0                              ;remember lower byte - Data now held in [s6,s5]
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return ends Read command
                        JUMP NZ, bad_input_command
                        LOAD s9, ED                              ;write memories upper byte
                        XOR s9, sA                               ;enable RAM 'A' or 'B'
                        OUTPUT s9, SRAM_control_port
                        OUTPUT s6, SRAM_data_out_port            ;output upper byte data to memories
                        XOR s9, SRAM_ram_we                      ;generate write enable pulse
                        OUTPUT s9, SRAM_control_port
                        XOR s9, SRAM_ram_we                      ;generate write enable pulse
                        OUTPUT s9, SRAM_control_port
                        LOAD s9, F6                              ;write memories lower byte
                        XOR s9, sA                               ;enable RAM 'A' or 'B'
                        OUTPUT s9, SRAM_control_port
                        OUTPUT s5, SRAM_data_out_port            ;output lower byte data to memories
                        XOR s9, SRAM_ram_we                      ;generate write enable pulse
                        OUTPUT s9, SRAM_control_port
                        XOR s9, SRAM_ram_we                      ;generate write enable pulse
                        OUTPUT s9, SRAM_control_port
                        LOAD s0, FF
                        OUTPUT s9, SRAM_control_port             ;disable memories
                        JUMP prompt_input
              bad_data: CALL send_Invalid
                        CALL send_Data
                        JUMP prompt_input
               bad_RAM: CALL send_Invalid
                        CALL send_RAM
                        JUMP prompt_input
                        ;
                        ;
                        ;
         test_for_Read: CALL read_RAM_letter                     ;test for RAM letter and space
                        COMPARE sA, 00                           ;check for invalid RAM letter and space
                        JUMP Z, bad_RAM
                        CALL set_RAM_address                     ;read and set address in range 00000 to 3FFFF
                        JUMP C, bad_address
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return ends Read command
                        JUMP NZ, bad_input_command
                        LOAD s9, AD                              ;read memories upper byte
                        XOR s9, sA                               ;enable RAM 'A' or 'B'
                        OUTPUT s9, SRAM_control_port
                        INPUT s0, SRAM_data_in_port              ;read memory
                        CALL send_hex_byte_to_UART               ;display upper byte
                        LOAD s9, B6                              ;read memories lower byte
                        XOR s9, sA                               ;enable RAM 'A' or 'B'
                        OUTPUT s9, SRAM_control_port
                        INPUT s0, SRAM_data_in_port              ;read memory
                        CALL send_hex_byte_to_UART               ;display lower byte
                        LOAD s0, FF
                        OUTPUT s9, SRAM_control_port             ;disable memories
                        CALL send_CR
                        JUMP prompt_input
           bad_address: CALL send_Invalid
                        CALL send_Address
                        JUMP prompt_input
                        ;
                        ;Reads the RAM specifier letter which must be 'A' or 'B' followed
                        ;by a space.
                        ;
                        ;sA will return with the corresponding CE position of the RAM
                        ;control output set or zero if incorrect syntax.
                        ;
       read_RAM_letter: LOAD sA, 00                              ;default value for error
                        CALL fetch_char_from_memory
                        LOAD s2, s0                              ;remember possible letter
                        CALL fetch_char_from_memory
                        COMPARE s0, character_space
                        RETURN NZ                                ;error if no space
                        COMPARE s2, character_A
                        JUMP Z, match_A
                        COMPARE s2, character_B
                        RETURN NZ                                ;error if not 'A' or 'B'
                        LOAD sA, SRAM_ram_b_ce
                        RETURN
               match_A: LOAD sA, SRAM_ram_a_ce
                        RETURN
                        ;
                        ;Reads the 5 didgit hexadecimal value in range 00000 to 3FFFF
                        ;
                        ;Address is set into the output registers if valid.
                        ;Invalid value will be indicated by CARRY flag being set.
                        ;
       set_RAM_address: CALL fetch_char_from_memory              ;read MS digit
                        CALL ASCII_to_hex                        ;convert to hex
                        RETURN C                                 ;Non Hex value so carry set
                        LOAD s2, 03                              ;test for bigger than '3'
                        SUB s2, s0
                        RETURN C                                 ;value to big so carry set
                        OUTPUT s0, upper_RAM_adddress            ;set upper address bits
                        CALL fetch_char_from_memory              ;read next 2 characters
                        LOAD s3, s0
                        CALL fetch_char_from_memory
                        LOAD s2, s0
                        CALL ASCII_byte_to_hex                   ;convert to hex in range 00 to FF
                        RETURN C                                 ;Non Hex value so carry set
                        OUTPUT s0, middle_RAM_adddress           ;set middle address bits
                        CALL fetch_char_from_memory              ;read next 2 characters
                        LOAD s3, s0
                        CALL fetch_char_from_memory
                        LOAD s2, s0
                        CALL ASCII_byte_to_hex                   ;convert to hex in range 00 to FF
                        RETURN C                                 ;Non Hex value so carry set
                        OUTPUT s0, lower_RAM_adddress            ;set lower address bits
                        RETURN
                        ;
                        ;
                        ;
         test_for_TIME: CALL fetch_char_from_memory
                        COMPARE s0, character_I                  ;test for rest of 'TIME'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_M
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_E
                        JUMP NZ, bad_input_command
                        ;now have a valid TIME command to process
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return means display time
                        JUMP NZ, set_time_command
                        CALL transmit_time                       ;transmit time to UART
                        JUMP prompt_input
      set_time_command: COMPARE s0, character_space
                        JUMP NZ, bad_input_command
                        CALL test_time_string                    ;interpret 'hh:mm:ss' string
                        JUMP C, prompt_input                     ;test for invalid input
                        STORE s6, real_time_hours                ;set new time into clock
                        STORE s5, real_time_minutes
                        STORE s4, real_time_seconds
                        STORE s0, ms_time_lsb                    ;clear 'ms' counter (s0=00)
                        STORE s0, ms_time_msb
                        CALL transmit_time                       ;transmit new time to UART
                        JUMP prompt_input
                        ;
                        ;
        test_for_ALARM: CALL fetch_char_from_memory
                        COMPARE s0, character_L                  ;test for rest of 'ALARM'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_A
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_R
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_M
                        JUMP NZ, bad_input_command
                        ;now have a valid ALARM command to process
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return means display alarm time
                        JUMP NZ, set_alarm_command
                        CALL transmit_alarm_time                 ;transmit time to UART
                        JUMP prompt_input
     set_alarm_command: COMPARE s0, character_space              ;test for ON or OFF command
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_O
                        JUMP Z, set_alarm_on_off
                        SUB s1, 01                               ;move memory pointer back to first character of 'hh:mm:ss' string
                        CALL test_time_string                    ;interpret 'hh:mm:ss' string
                        JUMP C, prompt_input                     ;test for invalid input
                        STORE s6, alarm_time_hours               ;set new time into clock
                        STORE s5, alarm_time_minutes
                        STORE s4, alarm_time_seconds
                        CALL transmit_alarm_time                 ;transmit new alarm time and status
                        JUMP prompt_input
      set_alarm_on_off: CALL fetch_char_from_memory
                        COMPARE s0, character_N                  ;test for 'ON'
                        JUMP NZ, test_OFF
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR
                        JUMP NZ, bad_input_command
                        FETCH s0, alarm_status                   ;turn alarm on
                        OR s0, alarm_armed
                        STORE s0, alarm_status
                        CALL transmit_alarm_time                 ;transmit alarm time and status
                        JUMP prompt_input
              test_OFF: COMPARE s0, character_F                  ;test for for 'OFF'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_F
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR
                        JUMP NZ, bad_input_command
                        LOAD s0, 00                              ;turn alarm off and stop an active alarm
                        STORE s0, alarm_status
                        CALL transmit_alarm_time                 ;transmit alarm time and status
                        JUMP prompt_input
                        ;
                        ;
          test_for_LED: CALL fetch_char_from_memory
                        COMPARE s0, character_E                  ;test for rest of 'LED'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_D
                        JUMP NZ, bad_input_command
                        ;now have a valid LED command to process
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return means display LED status
                        JUMP NZ, set_LED_command
                        CALL transmit_LED_status                 ;transmit LED status to UART
                        JUMP prompt_input
       set_LED_command: ADD s0, C8                               ;test for LED number in range 0 to 7 - convert ASCII to value
                        JUMP C, bad_LED_number                   ;character was more that '7'
                        ADD s0, 08
                        JUMP NC, bad_LED_number                  ;character was less than '7'
                        LOAD sA, 01                              ;set corresponding bit in sA
          LED_bit_loop: SUB s0, 01
                        JUMP C, set_LED_on_off
                        SL0 sA
                        JUMP LED_bit_loop
        set_LED_on_off: CALL fetch_char_from_memory
                        COMPARE s0, character_space              ;test for ON or OFF command
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_O
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_N                  ;test for 'ON'
                        JUMP NZ, test_LED_OFF
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR
                        JUMP NZ, bad_input_command
                        FETCH s0, LED_status                     ;turn LED on
                        OR s0, sA                                ;set appropriate bit
                        STORE s0, LED_status
                        CALL drive_LEDs                          ;turn on LEDs
                        JUMP prompt_input
          test_LED_OFF: COMPARE s0, character_F                  ;test for for 'OFF'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_F
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR
                        JUMP NZ, bad_input_command
                        FETCH s0, LED_status                     ;turn LED off
                        XOR sA, FF
                        AND s0, sA                               ;reset appropriate bit
                        STORE s0, LED_status
                        CALL drive_LEDs                          ;turn on LEDs
                        JUMP prompt_input
        bad_LED_number: CALL send_Invalid
                        CALL send_LED
                        CALL send_CR
                        JUMP prompt_input
                        ;
                        ;
       test_for_BUTTON: CALL fetch_char_from_memory
                        COMPARE s0, character_U                  ;test for rest of 'BUTTON'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_T
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_T
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_O
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_N
                        JUMP NZ, bad_input_command
                        ;now have a valid BUTTON command to process
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return means display BUTTON status
                        JUMP NZ, bad_input_command
                        INPUT sA, button_port
                        LOAD sB, 00                              ;bit counter
    button_status_loop: CALL send_Button                         ;transmist "Button" followed by number 0 to 7
                        LOAD UART_data, sB
                        ADD UART_data, character_0               ;convert to ASCII
                        CALL send_to_UART
                        CALL send_space
                        RR sA                                    ;test bit
                        JUMP C, button_is_on
                        CALL send_OFF
                        JUMP next_button_status
          button_is_on: CALL send_ON
    next_button_status: ADD sB, 01
                        COMPARE sB, 04
                        JUMP NZ, button_status_loop
                        JUMP prompt_input
                        ;
                        ;
       test_for_SWITCH: CALL fetch_char_from_memory
                        COMPARE s0, character_W                  ;test for rest of 'SWITCH'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_I
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_T
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_C
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_H
                        JUMP NZ, bad_input_command
                        ;now have a valid SWITCH command to process
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;carriage return means display SWITCH status
                        JUMP NZ, bad_input_command
                        INPUT sA, switch_port
                        LOAD sB, 00                              ;bit counter
    switch_status_loop: CALL send_Switch                         ;transmist "Switch" followed by number 0 to 7
                        LOAD UART_data, sB
                        ADD UART_data, character_0               ;convert to ASCII
                        CALL send_to_UART
                        CALL send_space
                        RR sA                                    ;test bit
                        JUMP C, switch_is_on
                        CALL send_OFF
                        JUMP next_switch_status
          switch_is_on: CALL send_ON
    next_switch_status: ADD sB, 01
                        COMPARE sB, 08
                        JUMP NZ, switch_status_loop
                        JUMP prompt_input
                        ;
                        ;Drive the simple LEDs based on memory value
                        ;
            drive_LEDs: FETCH s0, LED_status
                        OUTPUT s0, LED_port
                        RETURN
                        ;
                        ;Send status of LEDs to the UART
                        ;
   transmit_LED_status: FETCH sA, LED_status
                        LOAD sB, 00                              ;bit counter
       LED_status_loop: CALL send_LED                            ;transmist "LED" followed by number 0 to 7
                        LOAD UART_data, sB
                        ADD UART_data, character_0               ;convert to ASCII
                        CALL send_to_UART
                        CALL send_space
                        RR sA                                    ;test bit
                        JUMP C, LED_is_on
                        CALL send_OFF
                        JUMP next_LED_status
             LED_is_on: CALL send_ON
       next_LED_status: ADD sB, 01
                        COMPARE sB, 08
                        JUMP NZ, LED_status_loop
                        RETURN
                        ;
                        ;
                        ;
         test_for_PROM: CALL fetch_char_from_memory
                        COMPARE s0, character_R                  ;test for rest of 'ROM'
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_O
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_M
                        JUMP NZ, bad_input_command
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;valid PROM command ends in CR
                        JUMP NZ, bad_input_command
                        CALL send_CR                             ;prepare to display message on terminal
                        LOAD s0, 01                              ;reset the PROM and PROM reader circuit
                        OUTPUT s0, PROM_reset_port
                        LOAD s0, 00                              ;release reset and start search for first data byte
                        OUTPUT s0, PROM_reset_port
      prom_read_status: LOAD sB, FF                              ;16 bit timeout counter [sB,sA]
                        LOAD sA, FF
      prom_status_loop: SUB sA, 01                               ;decrement timeout counter
                        SUBCY sB, 00
                        JUMP C, prom_link_error
                        CALL update_time                         ;maintain time during long messages or delays
                        INPUT s0, PROM_status_port               ;test for data ready
                        TEST s0, PROM_data_ready
                        JUMP Z, prom_status_loop
                        INPUT UART_data, PROM_data_port          ;read data and start fetch of next data
                        COMPARE UART_data, FF                    ;end of data marker
                        JUMP Z, end_prom_message
                        CALL send_to_UART                        ;send to terminal
                        JUMP prom_read_status
       prom_link_error: CALL send_Link_JP1_Default
      end_prom_message: JUMP prompt_input
                        ;
                        ;
                        ;
                        ;
                        ;Read an 'hh:mm:ss' time string and provide new values.
                        ;
                        ;The string must be provided in successive scratch pad memory locations
                        ;with the s1 register containing the location of the first character.
                        ;
                        ;A correct time specification will result in the return of new values
                        ;as follows:-
                        ;
                        ;       s6 = hours
                        ;       s5 = minutes
                        ;       s4 = seconds
                        ;
                        ;If the syntax is incorrect or values are not in the correct ranges an
                        ;'Invalid Time' message will be transmitted and the CARRY flag will be set
                        ;
                        ;Registers used s0, s1, s6, s5 and s4
                        ;
      test_time_string: CALL 2char_to_value                      ;obtain hours value
                        JUMP C, invalid_time                     ;test for non-decimal characters
                        LOAD s6, s2                              ;remember hours
                        ADD s1, 01                               ;increment memory pointer past hours
                        CALL fetch_char_from_memory
                        COMPARE s0, character_colon              ;test for colon
                        JUMP NZ, invalid_time
                        CALL 2char_to_value                      ;obtain minutes value
                        JUMP C, invalid_time                     ;test for non-decimal characters
                        LOAD s5, s2                              ;remember minutes
                        ADD s1, 01                               ;increment memory pointer past minutes
                        CALL fetch_char_from_memory
                        COMPARE s0, character_colon              ;test for colon
                        JUMP NZ, invalid_time
                        CALL 2char_to_value                      ;obtain seconds value
                        JUMP C, invalid_time                     ;test for non-decimal characters
                        LOAD s4, s2                              ;remember minutes
                        ADD s1, 01                               ;increment memory pointer past seconds
                        CALL fetch_char_from_memory
                        COMPARE s0, character_CR                 ;finish with carriage return
                        JUMP NZ, invalid_time
                        ;Have values for hh:mm:ss but need to test if each is valid range.
                        COMPARE s6, hours_in_a_day
                        JUMP NC, invalid_time
                        COMPARE s5, minutes_in_an_hour
                        JUMP NC, invalid_time
                        COMPARE s4, seconds_in_a_minute
                        JUMP NC, invalid_time
                        LOAD s0, 00
                        SR0 s0                                   ;reset CARRY flag (with s0=0)
                        RETURN                                   ;time string was OK
          invalid_time: CALL send_Invalid
                        CALL send_Time
                        LOAD s0, 01
                        SR0 s0                                   ;set CARRY flag
                        RETURN                                   ;time string was bad
                        ;
                        ;
                        ;Fetch character from memory, convert to upper case
                        ;and increment memory pointer.
                        ;
                        ;The memory pointer is provided in register s1.
                        ;The character obtained is returned in register s0.
                        ;
                        ;Registers used s0 and s1.
                        ;
fetch_char_from_memory: FETCH s0, (s1)                           ;read character
                        CALL upper_case                          ;convert to upper case
                        ADD s1, 01                               ;increment memory pointer
                        RETURN
                        ;
                        ;
                        ;
                        ;Read one character from the UART
                        ;
                        ;Character read will be returned in a register called 'UART_data' and will be
                        ;echoed to the UART transmitter.
                        ;
                        ;The routine first tests the receiver FIFO buffer to see if data is present.
                        ;If the FIFO is empty, the routine waits until there is a character to read.
                        ;As this could take any amount of time the wait loop includes a call to the
                        ;subroutine which updates the real time clock.
                        ;
                        ;Registers used s0 and UART_data
                        ;
        read_from_UART: INPUT s0, UART_status_port               ;test Rx_FIFO buffer
                        TEST s0, rx_data_present
                        JUMP NZ, read_character
                        CALL update_time                         ;Perform useful operation whilst waiting
                        JUMP read_from_UART
        read_character: INPUT UART_data, UART_read_port          ;read from FIFO
                        CALL send_to_UART                        ;echo received character
                        RETURN
                        ;
                        ;
                        ;
                        ;Transmit one character to the UART
                        ;
                        ;Character supplied in register called 'UART_data'.
                        ;
                        ;The routine first tests the transmit FIFO buffer to see if it is full.
                        ;If the FIFO is full, the routine waits until there is space which could
                        ;be as long as it takes to transmit one complete character.
                        ;
                        ;    Baud Rate    Time per Character (10 bits)
                        ;      9600           1,024us
                        ;     19200             521us
                        ;     38400             260us
                        ;     57600             174us
                        ;    115200              87us
                        ;
                        ;Since this is a relatively long duration, the wait loop includes a
                        ;call to the subroutine which updates the real time clock.
                        ;
                        ;Registers used s0
                        ;
          send_to_UART: INPUT s0, UART_status_port               ;test Tx_FIFO buffer
                        TEST s0, tx_full
                        JUMP Z, UART_write
                        CALL update_time                         ;Perform useful operation whilst waiting
                        JUMP send_to_UART
            UART_write: OUTPUT UART_data, UART_write_port
                        RETURN
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;Transmit the time to the UART port in the format hh:mm:ss and end
                        ;with a carriage return.
                        ;
                        ;The time to converted must be stored in 3 scratch pad memory locations as
                        ;defined below. A register named 'store_pointer' must provide the address of
                        ;first location.
                        ;
                        ;        Address                Data
                        ;
                        ;     store_pointer      ----> hours
                        ;     store_pointer + 1  ----> minutes
                        ;     store_pointer + 1  ----> seconds
                        ;
                        ;The routine first converts the time into an ASCII string stored in scratch
                        ;pad memory starting at a location specified by a constant named 'string_start'.
                        ;The string will then be transmitted.
                        ;
                        ;Registers used s0, s1, s2, 'store_pointer' and 'UART_data'.
                        ;
         transmit_time: LOAD store_pointer, real_time_hours      ;locate current time in memory
                        CALL time_to_ASCII
                        CALL transmit_string
                        RETURN
                        ;
                        ;
                        ;Transmit the alarm time and status to the UART port in the format hh:mm:ss and
                        ;ending with carriage return.
                        ;
                        ;The alarm time to converted must be stored in 3 scratch pad memory locations as
                        ;defined below. A register named 'store_pointer' must provide the address of
                        ;first location.
                        ;
                        ;        Address                Data
                        ;
                        ;     store_pointer      ----> hours
                        ;     store_pointer + 1  ----> minutes
                        ;     store_pointer + 1  ----> seconds
                        ;
                        ;The routine first converts the time into an ASCII string stored in scratch
                        ;pad memory starting at a location specified by a constant named 'string_start'.
                        ;The string will then be transmitted.
                        ;
                        ;Registers used s0, s1, s2, 'store_pointer' and 'UART_data'.
                        ;
   transmit_alarm_time: LOAD store_pointer, alarm_time_hours     ;locate alarm time in memory
                        CALL time_to_ASCII
                        CALL transmit_string
                        CALL send_Alarm
                        CALL send_space
                        FETCH s0, alarm_status                   ;read alarm status
                        TEST s0, alarm_active                    ;test for active
                        JUMP Z, test_armed
                        CALL send_Active
                        RETURN
            test_armed: TEST s0, alarm_armed                     ;test for on
                        JUMP Z, alarm_is_off
                        CALL send_ON
                        RETURN
          alarm_is_off: CALL send_OFF
                        RETURN
                        ;
                        ;
                        ;Transmit ASCII string to UART
                        ;
                        ;An ASCII string must be provided in scratch pad memory commencing at the
                        ;location specified by a constant named 'string_start'. The string must
                        ;end with a carriage return (0D) which is transmitted.
                        ;
                        ;Registers used s1 and 'UART_data'.
                        ;               s0 is then used in subroutine 'send_to_UART'
                        ;
       transmit_string: LOAD s1, string_start                    ;locate start of string
          next_char_tx: FETCH UART_data, (s1)                    ;read character from memory
                        CALL send_to_UART                        ;transmit character
                        COMPARE UART_data, character_CR          ;test for last character
                        RETURN Z
                        ADD s1, 01                               ;move to next character
                        JUMP next_char_tx
                        ;
                        ;
                        ;Receive ASCII string from UART
                        ;
                        ;An ASCII string will be read from the UART and stored in scratch pad memory
                        ;commencing at the location specified by a constant named 'string_start'.
                        ;The string will will have a maximum length of 16 characters including a
                        ;carriage return (0D) denoting the end of the string.
                        ;
                        ;As each character is read, it is echoed to the UART transmitter.
                        ;Some minor editing is supported using backspace (BS=08) which is used
                        ;to adjust what is stored in scratch pad memory and adjust the display
                        ;on the terminal screen using characters sent to the UART transmitter.
                        ;
                        ;A test is made for the receiver FIFO becoming full. A full status is treated as
                        ;a potential error situation and will result in a 'Overflow Error' message being
                        ;transmitted to the UART, the receiver FIFO being purged of all data and an
                        ;empty string being stored (carriage return at first location).
                        ;
                        ;Registers used s0, s1, s2 and 'UART_data'.
                        ;
        receive_string: LOAD s1, string_start                    ;locate start of string
                        LOAD s2, s1                              ;compute 16 character address
                        ADD s2, 10
     receive_full_test: INPUT s0, UART_status_port               ;test Rx_FIFO buffer for full
                        TEST s0, rx_full
                        JUMP NZ, read_error
                        CALL read_from_UART                      ;obtain and echo character
                        STORE UART_data, (s1)                    ;write to memory
                        COMPARE UART_data, character_CR          ;test for end of string
                        RETURN Z
                        COMPARE UART_data, character_BS          ;test for back space
                        JUMP Z, BS_edit
                        ADD s1, 01                               ;increment memory pointer
                        COMPARE s1, s2                           ;test for pointer exceeding 16 characters
                        JUMP NZ, receive_full_test               ;next character
                        CALL send_backspace                      ;hold end of string position on terminal display
               BS_edit: SUB s1, 01                               ;memory pointer back one
                        COMPARE s1, string_start                 ;test for under flow
                        JUMP C, string_start_again
                        CALL send_space                          ;clear character at current position
                        CALL send_backspace                      ;position cursor
                        JUMP receive_full_test                   ;next character
    string_start_again: CALL send_greater_than                   ;restore '>' at prompt
                        JUMP receive_string                      ;begin again
                        ;Receiver buffer overflow condition
            read_error: CALL send_CR                             ;Transmit error message
                        STORE UART_data, string_start            ;empty string in memory (start with CR)
                        CALL send_Overflow_Error
                        CALL send_CR
    clear_UART_Rx_loop: INPUT s0, UART_status_port               ;test Rx_FIFO buffer for data
                        TEST s0, rx_data_present
                        RETURN Z                                 ;finish when buffer is empty
                        INPUT UART_data, UART_read_port          ;read from FIFO and ignore
                        JUMP clear_UART_Rx_loop
                        ;
                        ;
                        ;
                        ;Send Carriage Return to the UART
                        ;
               send_CR: LOAD UART_data, character_CR
                        CALL send_to_UART
                        RETURN
                        ;
                        ;
                        ;
                        ;Send a space to the UART
                        ;
            send_space: LOAD UART_data, character_space
                        CALL send_to_UART
                        RETURN
                        ;
                        ;
                        ;Send a back space to the UART
                        ;
        send_backspace: LOAD UART_data, character_BS
                        CALL send_to_UART
                        RETURN
                        ;
                        ;Send 'Link JP1 Default' to the UART
                        ;
 send_Link_JP1_Default: LOAD UART_data, character_C
                        CALL send_to_UART
                        LOAD UART_data, character_h
                        CALL send_to_UART
                        LOAD UART_data, character_e
                        CALL send_to_UART
                        LOAD UART_data, character_c
                        CALL send_to_UART
                        LOAD UART_data, character_k
                        CALL send_to_UART
                        CALL send_space
                        LOAD UART_data, character_J
                        CALL send_to_UART
                        LOAD UART_data, character_P
                        CALL send_to_UART
                        LOAD UART_data, character_1
                        CALL send_to_UART
                        CALL send_space
                        LOAD UART_data, character_l
                        CALL send_to_UART
                        LOAD UART_data, character_i
                        CALL send_to_UART
                        LOAD UART_data, character_n
                        CALL send_to_UART
                        LOAD UART_data, character_k
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'Syntax Error' to the UART
                        ;
     send_Syntax_Error: LOAD UART_data, character_S
                        CALL send_to_UART
                        LOAD UART_data, character_y
                        CALL send_to_UART
                        LOAD UART_data, character_n
                        CALL send_to_UART
                        LOAD UART_data, character_t
                        CALL send_to_UART
                        LOAD UART_data, character_a
                        CALL send_to_UART
                        LOAD UART_data, character_x
                        CALL send_to_UART
                        JUMP send_space_Error
                        ;
                        ;Send 'Overflow Error' to the UART
                        ;
   send_Overflow_Error: LOAD UART_data, character_O
                        CALL send_to_UART
                        LOAD UART_data, character_v
                        CALL send_to_UART
                        LOAD UART_data, character_e
                        CALL send_to_UART
                        LOAD UART_data, character_r
                        CALL send_to_UART
                        LOAD UART_data, character_f
                        CALL send_to_UART
                        LOAD UART_data, character_l
                        CALL send_to_UART
                        LOAD UART_data, character_o
                        CALL send_to_UART
                        LOAD UART_data, character_w
                        CALL send_to_UART
      send_space_Error: CALL send_space
                        ;
                        ;Send 'Error' to the UART
                        ;
            send_Error: LOAD UART_data, character_E
                        CALL send_to_UART
                        LOAD UART_data, character_r
                        CALL send_to_UART
                        CALL send_to_UART
                        LOAD UART_data, character_o
                        CALL send_to_UART
                        LOAD UART_data, character_r
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'KCPSM3>' prompt to the UART
                        ;
           send_prompt: CALL send_CR                             ;start new line
                        LOAD UART_data, character_K
                        CALL send_to_UART
                        LOAD UART_data, character_C
                        CALL send_to_UART
                        LOAD UART_data, character_P
                        CALL send_to_UART
                        LOAD UART_data, character_S
                        CALL send_to_UART
                        LOAD UART_data, character_M
                        CALL send_to_UART
                        LOAD UART_data, character_3
                        CALL send_to_UART
                        ;
                        ;Send '>' character to the UART
                        ;
     send_greater_than: LOAD UART_data, character_greater_than
                        CALL send_to_UART
                        RETURN
                        ;
                        ;Send 'Invalid' string to the UART
                        ;
          send_Invalid: LOAD UART_data, character_I
                        CALL send_to_UART
                        LOAD UART_data, character_n
                        CALL send_to_UART
                        LOAD UART_data, character_v
                        CALL send_to_UART
                        LOAD UART_data, character_a
                        CALL send_to_UART
                        LOAD UART_data, character_l
                        CALL send_to_UART
                        LOAD UART_data, character_i
                        CALL send_to_UART
                        LOAD UART_data, character_d
                        CALL send_to_UART
                        CALL send_space
                        RETURN
                        ;
                        ;Send 'Address' string to the UART
                        ;
          send_Address: LOAD UART_data, character_A
                        CALL send_to_UART
                        LOAD UART_data, character_d
                        CALL send_to_UART
                        CALL send_to_UART
                        LOAD UART_data, character_r
                        CALL send_to_UART
                        LOAD UART_data, character_e
                        CALL send_to_UART
                        LOAD UART_data, character_s
                        CALL send_to_UART
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'Data' string to the UART
                        ;
             send_Data: LOAD UART_data, character_D
                        CALL send_to_UART
                        LOAD UART_data, character_a
                        CALL send_to_UART
                        LOAD UART_data, character_t
                        CALL send_to_UART
                        LOAD UART_data, character_a
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'RAM' string to the UART
                        ;
              send_RAM: LOAD UART_data, character_R
                        CALL send_to_UART
                        LOAD UART_data, character_A
                        CALL send_to_UART
                        LOAD UART_data, character_M
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'Time' string to the UART
                        ;
             send_Time: LOAD UART_data, character_T
                        CALL send_to_UART
                        LOAD UART_data, character_i
                        CALL send_to_UART
                        LOAD UART_data, character_m
                        CALL send_to_UART
                        LOAD UART_data, character_e
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'Alarm' string to the UART
                        ;
            send_Alarm: LOAD UART_data, character_A
                        CALL send_to_UART
                        LOAD UART_data, character_l
                        CALL send_to_UART
                        LOAD UART_data, character_a
                        CALL send_to_UART
                        LOAD UART_data, character_r
                        CALL send_to_UART
                        LOAD UART_data, character_m
                        CALL send_to_UART
                        RETURN
                        ;
                        ;Send 'OFF' string to the UART
                        ;
              send_OFF: LOAD UART_data, character_O
                        CALL send_to_UART
                        LOAD UART_data, character_F
                        CALL send_to_UART
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'ON' string to the UART
                        ;
               send_ON: LOAD UART_data, character_O
                        CALL send_to_UART
                        LOAD UART_data, character_N
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'Active' string to the UART
                        ;
           send_Active: LOAD UART_data, character_A
                        CALL send_to_UART
                        LOAD UART_data, character_c
                        CALL send_to_UART
                        LOAD UART_data, character_t
                        CALL send_to_UART
                        LOAD UART_data, character_i
                        CALL send_to_UART
                        LOAD UART_data, character_v
                        CALL send_to_UART
                        LOAD UART_data, character_e
                        CALL send_to_UART
                        JUMP send_CR
                        ;
                        ;Send 'Switch' string to the UART
                        ;
           send_Switch: LOAD UART_data, character_S
                        CALL send_to_UART
                        LOAD UART_data, character_w
                        CALL send_to_UART
                        LOAD UART_data, character_i
                        CALL send_to_UART
                        LOAD UART_data, character_t
                        CALL send_to_UART
                        LOAD UART_data, character_c
                        CALL send_to_UART
                        LOAD UART_data, character_h
                        CALL send_to_UART
                        RETURN
                        ;
                        ;Send 'Button' string to the UART
                        ;
           send_Button: LOAD UART_data, character_B
                        CALL send_to_UART
                        LOAD UART_data, character_u
                        CALL send_to_UART
                        LOAD UART_data, character_t
                        CALL send_to_UART
                        CALL send_to_UART
                        LOAD UART_data, character_o
                        CALL send_to_UART
                        LOAD UART_data, character_n
                        CALL send_to_UART
                        RETURN
                        ;
                        ;Send 'LED' string to the UART
                        ;
              send_LED: LOAD UART_data, character_L
                        CALL send_to_UART
                        LOAD UART_data, character_E
                        CALL send_to_UART
                        LOAD UART_data, character_D
                        CALL send_to_UART
                        RETURN
                        ;
                        ;
                        ;Convert time to ASCII string in scratch pad memory.
                        ;
                        ;The time to converted must be stored in 3 scratch pad memory locations as
                        ;defined below. A register named 'store_pointer' must provide the address of
                        ;first location.
                        ;
                        ;        Address                Data
                        ;
                        ;     store_pointer      ----> hours
                        ;     store_pointer + 1  ----> minutes
                        ;     store_pointer + 1  ----> seconds
                        ;
                        ;The resulting ASCII string will be stored in scratch pad memory starting at
                        ;a location specified by a constant named 'string_start'. The string will
                        ;take the format hh:mm:ss and end with a carriage return.
                        ;
                        ;Registers used s0, s1, s2 and 'store_pointer'.
                        ;
         time_to_ASCII: LOAD s2, string_start                    ;location for string
                        FETCH s0, (store_pointer)                ;read hours value
                        CALL decimal_to_ASCII                    ;convert to ASCII
                        STORE s1, (s2)                           ;write hours to string
                        ADD s2, 01
                        STORE s0, (s2)
                        ADD s2, 01
                        LOAD s0, character_colon                 ;write ':' to string
                        STORE s0, (s2)
                        ADD s2, 01
                        ADD store_pointer, 01                    ;move to minutes
                        FETCH s0, (store_pointer)                ;read minutes value
                        CALL decimal_to_ASCII                    ;convert to ASCII
                        STORE s1, (s2)                           ;write minutes to string
                        ADD s2, 01
                        STORE s0, (s2)
                        ADD s2, 01
                        LOAD s0, character_colon                 ;write ':' to string
                        STORE s0, (s2)
                        ADD s2, 01
                        ADD store_pointer, 01                    ;move to seconds
                        FETCH s0, (store_pointer)                ;read seconds value
                        CALL decimal_to_ASCII                    ;convert to ASCII
                        STORE s1, (s2)                           ;write seconds to string
                        ADD s2, 01
                        STORE s0, (s2)
                        ADD s2, 01
                        LOAD s0, character_CR                    ;finish string with carriage return
                        STORE s0, (s2)
                        RETURN
                        ;
                        ;Convert value provided in register s0 into ASCII characters
                        ;
                        ;The value provided must in the range 0 to 99 and will be converted into
                        ;two ASCII characters.
                        ;     The number of 'tens' will be representd by an ASCII character returned in register s1.
                        ;     The number of 'units' will be representd by an ASCII character returned in register s0.
                        ;
                        ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
                        ;the actual decimal value.
                        ;
                        ;Registers used s0 and s1.
                        ;
      decimal_to_ASCII: LOAD s1, 30                              ;load 'tens' counter with ASCII for '0'
          test_for_ten: ADD s1, 01                               ;increment 'tens' value
                        SUB s0, 0A                               ;try to subtract 10 from the supplied value
                        JUMP NC, test_for_ten                    ;repeat if subtraction was possible without underflow.
                        SUB s1, 01                               ;'tens' value one less ten due to underflow
                        ADD s0, 3A                               ;restore units value (the remainder) and convert to ASCII
                        RETURN
                        ;
                        ;
                        ;
                        ;
                        ;Real Time Clock
                        ;
                        ;Uses the 1us interrupt counter [int_counter_msb,int_counter_lsb] to determine how many
                        ;micro-seconds have elapsed since the last update. This allows for just over 65ms between
                        ;updates. Complete multiples of 1000us are used to update a 16-bit milli-second counter held
                        ;in scratch pad memory locations [ms_time_stamp_msb,ms_time_stamp_msb] which in turn
                        ;is used to update the real time hours, minutes and seconds clock held in scratch pad
                        ;memory locations 'real_time_hours', 'real_time_minutes' and 'real_time_seconds'.
                        ;
                        ;The routine uses default register names s0,s1,s2,s3,s4,s5. These are preserved in scratch pad
                        ;memory during the routine and restored before returning.
                        ;
                        ;Useful constants for real time clock operations
                        ;
                        CONSTANT count_1000_lsb, E8              ;lower 8-bits of 1000 count value
                        CONSTANT count_1000_msb, 03              ;upper 8-bits of 1000 count value
                        CONSTANT hours_in_a_day, 18              ;24 hours in a day
                        CONSTANT minutes_in_an_hour, 3C          ;60 minutes in an hour
                        CONSTANT seconds_in_a_minute, 3C         ;60 seconds in a minute
                        ;
           update_time: STORE s0, time_preserve0                 ;preserve contents of registers used during routine
                        STORE s1, time_preserve1
                        STORE s2, time_preserve2
                        STORE s3, time_preserve3
                        STORE s4, time_preserve4
                        STORE s5, time_preserve5
                        ;
                        FETCH s2, us_time_stamp_lsb              ;read the previous 'us' time stamp into [s3,s2]
                        FETCH s3, us_time_stamp_msb
                        DISABLE INTERRUPT                        ;Read and store current 'us' time stamp provided by the interrupt
                        STORE int_counter_lsb, us_time_stamp_lsb ;counter. Interrupts are disabled to ensure that both bytes relate
                        STORE int_counter_msb, us_time_stamp_msb ;to the same count value.
                        ENABLE INTERRUPT
                        FETCH s4, us_time_stamp_lsb              ;read the new 'us' time stamp in [s5,s4]
                        FETCH s5, us_time_stamp_msb              ;
                        SUB s4, s2                               ;calculate 'us' time difference [s5,s4] = [s5,s4] - [s3,s2]
                        SUBCY s5, s3                             ;   (This works correctly even if counter has rolled over)
                        FETCH s2, us_time_lsb                    ;read current 'us' time into [s3,s2]
                        FETCH s3, us_time_msb
                        ADD s2, s4                               ;add on the elapsed 'us' value [s3,s2] = [s3,s2] + [s5,s4]
                        ADDCY s3, s5
                        ;determine how many 1000us (1ms) units there are (if any) in current 'us' time
                        LOAD s0, 00                              ;reset 'ms' counter
           test_1000us: SUB s2, count_1000_lsb                   ;subtract 1000 from [s3,s2]
                        SUBCY s3, count_1000_msb
                        JUMP C, store_us_time                    ;Carry indicates [s3,s2] was less than 1000us
                        ADD s0, 01                               ;increment 'ms' elapsed because [s3,s2] was more or equal to 1000us
                        JUMP test_1000us                         ;repeat to see if more than 1ms has elapsed
         store_us_time: ADD s2, count_1000_lsb                   ;add 1000 to restore 'us' value
                        ADDCY s3, count_1000_msb
                        STORE s2, us_time_lsb                    ;store the current value of 'us'
                        STORE s3, us_time_msb
                        ;s0 holds the number of 'ms' elapsed since last update (if any).
                        FETCH s2, ms_time_lsb                    ;read current 'ms' time into [s3,s2]
                        FETCH s3, ms_time_msb
                        ADD s2, s0                               ;add on the elapsed 'ms' value [s3,s2] = [s3,s2] + s0
                        ADDCY s3, 00
                        ;determine if there are now more than 1000ms to form 1 second.
                        LOAD s0, 00                              ;reset 'second' counter
                        SUB s2, count_1000_lsb                   ;subtract 1000 from [s3,s2]
                        SUBCY s3, count_1000_msb
                        JUMP C, restore_ms_time                  ;Carry indicates [s3,s2] was less than 1000ms
                        ADD s0, 01                               ;increment 'second' elapsed because [s3,s2] was more or equal to 1000ms
                        JUMP store_ms_time                       ;new value of 'ms' is remainder of subtraction
       restore_ms_time: ADD s2, count_1000_lsb                   ;add 1000 to restore 'ms' value
                        ADDCY s3, count_1000_msb
         store_ms_time: STORE s2, ms_time_lsb                    ;store the current value of 'ms'
                        STORE s3, ms_time_msb
                        ;s0 currently determines if one second needs to be added to the hh:mm:ss clock time
                        FETCH s1, real_time_seconds              ;read seconds
                        ADD s1, s0                               ;add one second if required by s0
                        COMPARE s1, seconds_in_a_minute          ;test for 1 minute
                        JUMP Z, inc_minutes
                        STORE s1, real_time_seconds              ;store updated seconds
                        JUMP time_update_complete
           inc_minutes: LOAD s1, 00                              ;seconds become zero
                        STORE s1, real_time_seconds
                        FETCH s1, real_time_minutes              ;read minutes
                        ADD s1, 01                               ;increment minutes
                        COMPARE s1, minutes_in_an_hour           ;test for 1 hour
                        JUMP Z, inc_hours
                        STORE s1, real_time_minutes              ;store updated minutes
                        JUMP time_update_complete
             inc_hours: LOAD s1, 00                              ;minutes become zero
                        STORE s1, real_time_minutes
                        FETCH s1, real_time_hours                ;read hours
                        ADD s1, 01                               ;increment hours
                        COMPARE s1, hours_in_a_day               ;test for 24 hours
                        JUMP Z, reset_hours
                        STORE s1, real_time_hours                ;store updated hours
                        JUMP time_update_complete
           reset_hours: LOAD s1, 00                              ;hours become zero
                        STORE s1, real_time_hours
                        ;
                        ;With the time updated, there is then a test for time=alarm time
                        ;
  time_update_complete: FETCH s0, real_time_hours
                        FETCH s1, alarm_time_hours               ;compare hours
                        COMPARE s0, s1
                        JUMP NZ, finish_update
                        FETCH s0, real_time_minutes              ;compare minutes
                        FETCH s1, alarm_time_minutes
                        COMPARE s0, s1
                        JUMP NZ, finish_update
                        FETCH s0, real_time_seconds              ;compare seconds
                        FETCH s1, alarm_time_seconds
                        COMPARE s0, s1
                        JUMP NZ, finish_update
                        FETCH s0, alarm_status                   ;test if alarm is turned on
                        TEST s0, alarm_armed
                        JUMP Z, finish_update                    ;alarm was off
                        OR s0, alarm_active                      ;activate alarm
                        STORE s0, alarm_status
                        ;
                        ;The 7-segment display is also updated
                        ;
         finish_update: LOAD s5, FF                              ;decimal points will be off by default
                        FETCH s0, alarm_status                   ;determine if alarm is active
                        TEST s0, alarm_active
                        JUMP Z, flash_point
                        LOAD s5, 7F                              ;MSB reset if alarm is active - decimal points will be on
           flash_point: LOAD s4, FF                              ;second point will be off by default
                        FETCH s0, ms_time_msb                    ;determine if milli seconds exceed 512ms
                        TEST s0, 02
                        JUMP Z, hours_7seg
                        LOAD s4, 7F                              ;MSB reset to flash second decimal points each second
            hours_7seg: FETCH s0, real_time_hours                ;drive 7-segment display with hours and minutes
                        LOAD s1, 00                              ;load 'tens' counter with '0'
    test_for_ten_hours: ADD s1, 01                               ;increment 'tens' value
                        SUB s0, 0A                               ;try to subtract 10 from hours value
                        JUMP NC, test_for_ten_hours              ;repeat if subtraction was possible without underflow.
                        SUB s1, 01                               ;'tens' value one less ten due to underflow
                        ADD s0, 0A                               ;restore units value (the remainder)
                        CALL value_to_7segement                  ;convert hour units to digit display
                        AND s2, s4                               ;reset decimal point if second flash required
                        OUTPUT s2, digit2_RAM
                        LOAD s0, s1
                        CALL value_to_7segement                  ;convert hour tens to digit display
                        AND s2, s5                               ;reset decimal point if alarm active
                        OUTPUT s2, digit3_RAM
                        FETCH s0, real_time_minutes
                        LOAD s1, 00                              ;load 'tens' counter with '0'
  test_for_ten_minutes: ADD s1, 01                               ;increment 'tens' value
                        SUB s0, 0A                               ;try to subtract 10 from hours value
                        JUMP NC, test_for_ten_minutes            ;repeat if subtraction was possible without underflow.
                        SUB s1, 01                               ;'tens' value one less ten due to underflow
                        ADD s0, 0A                               ;restore units value (the remainder)
                        CALL value_to_7segement                  ;convert minutes units to digit display
                        AND s2, s5                               ;reset decimal point if alarm active
                        OUTPUT s2, digit0_RAM
                        LOAD s0, s1
                        CALL value_to_7segement                  ;convert minutes tens to digit display
                        AND s2, s5                               ;reset decimal point if alarm active
                        OUTPUT s2, digit1_RAM
                        ;
                        FETCH s0, time_preserve0                 ;restore the register contents
                        FETCH s1, time_preserve1
                        FETCH s2, time_preserve2
                        FETCH s3, time_preserve3
                        FETCH s4, time_preserve4
                        FETCH s5, time_preserve5
                        RETURN
                        ;
                        ;Convert value supplied in register s0 to 7-segement digit drive in s2
                        ;
                        ;The value must be in the range 0 to 9 or the digit will be blank
                        ;
                        ;Registers used s0.
                        ;
    value_to_7segement: LOAD s2, digit_0
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_1
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_2
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_3
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_4
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_5
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_6
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_7
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_8
                        SUB s0, 01
                        RETURN C
                        LOAD s2, digit_9
                        SUB s0, 01
                        RETURN C
                        LOAD s2, FF                              ;blank digit
                        RETURN
                        ;
                        ;Convert character to upper case
                        ;
                        ;The character supplied in register s0.
                        ;If the character is in the range 'a' to 'z', it is converted
                        ;to the equivalent upper case character in the range 'A' to 'Z'.
                        ;All other characters remain unchanged.
                        ;
                        ;Registers used s0.
                        ;
            upper_case: COMPARE s0, 61                           ;eliminate character codes below 'a' (61 hex)
                        RETURN C
                        COMPARE s0, 7B                           ;eliminate character codes above 'z' (7A hex)
                        RETURN NC
                        AND s0, DF                               ;mask bit5 to convert to upper case
                        RETURN
                        ;
                        ;
                        ;Convert character '0' to '9' to numerical value in range 0 to 9
                        ;
                        ;The character supplied in register s0. If the character is in the
                        ;range '0' to '9', it is converted to the equivalent decimal value.
                        ;Characters not in the range '0' to '9' are signified by the return
                        ;with the CARRY flag set.
                        ;
                        ;Registers used s0.
                        ;
        1char_to_value: ADD s0, C6                               ;reject character codes above '9' (39 hex)
                        RETURN C                                 ;carry flag is set
                        SUB s0, F6                               ;reject character codes below '0' (30 hex)
                        RETURN                                   ;carry is set if value not in range
                        ;
                        ;
                        ;Determine the numerical value of a two character decimal string held in
                        ;scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
                        ;
                        ;The string must be stored as in two consecutive memory locations and the
                        ;location of the first (tens) character supplied in the s1 register.
                        ;The result is provided in register s2. Strings not using characters in the
                        ;range '0' to '9' are signified by the return with the CARRY flag set.
                        ;
                        ;Registers used s0, s1 and s2.
                        ;
        2char_to_value: FETCH s0, (s1)                           ;read 'tens' character
                        CALL 1char_to_value                      ;convert to numerical value
                        RETURN C                                 ;bad character - CARRY set
                        LOAD s2, s0
                        SL0 s2                                   ;multiply 'tens' value by 10 (0A hex)
                        SL0 s2
                        ADD s2, s0
                        SL0 s2
                        ADD s1, 01                               ;read 'units' character
                        FETCH s0, (s1)
                        CALL 1char_to_value                      ;convert to numerical value
                        RETURN C                                 ;bad character - CARRY set
                        ADD s2, s0                               ;add units to result and clear CARRY flag
                        RETURN
                        ;
                        ;Send the hexadecimal value provided in register s0 as 2 ASCII characters to the UART
                        ;
                        ;Registers used s0, s1 and s2.
                        ;
 send_hex_byte_to_UART: CALL hex_byte_to_ASCII                   ;convert
                        LOAD UART_data, s2                       ;tranismit upper nibble
                        CALL send_to_UART
                        LOAD UART_data, s1                       ;tranismit lower nibble
                        CALL send_to_UART
                        RETURN
                        ;
                        ;Convert hexadecimal value provided in register s0 into ASCII characters
                        ;
                        ;The value provided must can be any value in the range 00 to FF and will be converted into
                        ;two ASCII characters.
                        ;     The upper nibble will be representd by an ASCII character returned in register s2.
                        ;     The lower nibble will be representd by an ASCII character returned in register s1.
                        ;
                        ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                        ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                        ;hexadecimal requiring a further addition of 07 to the 30 already added.
                        ;
                        ;Registers used s0, s1 and s2.
                        ;
     hex_byte_to_ASCII: LOAD s1, s0                              ;remember value supplied
                        SR0 s0                                   ;isolate upper nibble
                        SR0 s0
                        SR0 s0
                        SR0 s0
                        CALL hex_to_ASCII                        ;convert
                        LOAD s2, s0                              ;upper nibble value in s2
                        LOAD s0, s1                              ;restore complete value
                        AND s0, 0F                               ;isolate lower nibble
                        CALL hex_to_ASCII                        ;convert
                        LOAD s1, s0                              ;lower nibble value in s1
                        RETURN
                        ;
                        ;Convert hexadecimal value provided in register s0 into ASCII character
                        ;
                        ;Register used s0
                        ;
          hex_to_ASCII: SUB s0, 0A                               ;test if value is in range 0 to 9
                        JUMP C, number_char
                        ADD s0, 07                               ;ASCII char A to F in range 41 to 46
           number_char: ADD s0, 3A                               ;ASCII char 0 to 9 in range 30 to 40
                        RETURN
                        ;
                        ;Convert the HEX ASCII characters contained in 's3' and 's2' into
                        ;an equivalent hexadecimal value in register 's0'.
                        ;     The upper nibble is representd by an ASCII character in register s3.
                        ;     The lower nibble is representd by an ASCII character in register s2.
                        ;
                        ;Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                        ;will be set on return.
                        ;
                        ;Registers used s0, s2 and s3.
                        ;
     ASCII_byte_to_hex: LOAD s0, s3                              ;Take upper nibble
                        CALL ASCII_to_hex                        ;convert to value
                        RETURN C                                 ;reject if out of range
                        LOAD s3, s0                              ;remember value
                        SL0 s3                                   ;multiply value by 16 to put in upper nibble
                        SL0 s3
                        SL0 s3
                        SL0 s3
                        LOAD s0, s2                              ;Take lower nibble
                        CALL ASCII_to_hex                        ;convert to value
                        RETURN C                                 ;reject if out of range
                        OR s0, s3                                ;merge in the upper nibble with CARRY reset
                        RETURN
                        ;
                        ;
                        ;Routine to convert ASCII data in 's0' to an equivalent HEX value.
                        ;
                        ;If character is not valid for hex, then CARRY is set on return.
                        ;
                        ;Register used s0
                        ;
          ASCII_to_hex: ADD s0, B9                               ;test for above ASCII code 46 ('F')
                        RETURN C
                        SUB s0, E9                               ;normalise 0 to 9 with A-F in 11 to 16 hex
                        RETURN C                                 ;reject below ASCII code 30 ('0')
                        SUB s0, 11                               ;isolate A-F down to 00 to 05 hex
                        JUMP NC, ASCII_letter
                        ADD s0, 07                               ;test for above ASCII code 46 ('F')
                        RETURN C
                        SUB s0, F6                               ;convert to range 00 to 09
                        RETURN
          ASCII_letter: ADD s0, 0A                               ;convert to range 0A to 0F
                        RETURN
                        ;
                        ;
                        ;Interrupt service routine (ISR)
                        ;
                        ;The interrupt is used to increment a 16-bit counter formed with two registers
                        ;called [int_counter_msb,int_counter_lsb]. This provides a count of the number
                        ;of micro-seconds elapsed. The counter is 'free running' in that it will count
                        ;up to 65,535 and then roll over to zero. The count value is then used in other
                        ;parts of the program as required and where it is less time critical.
                        ;
                        ;The ISR only uses the specified counter registers
                        ;
                        ADDRESS 3FC
                   ISR: ADD int_counter_lsb, 01                  ;add 1us to 16-bit counter
                        ADDCY int_counter_msb, 00
                        RETURNI ENABLE
                        ;
                        ;Interrupt vector
                        ;
                        ADDRESS 3FF
                        JUMP ISR
                        ;
                        ;
                        ;Useful constants
                        ;
                        ;
                        ;ASCII table
                        ;
                        CONSTANT character_a, 61
                        CONSTANT character_b, 62
                        CONSTANT character_c, 63
                        CONSTANT character_d, 64
                        CONSTANT character_e, 65
                        CONSTANT character_f, 66
                        CONSTANT character_g, 67
                        CONSTANT character_h, 68
                        CONSTANT character_i, 69
                        CONSTANT character_j, 6A
                        CONSTANT character_k, 6B
                        CONSTANT character_l, 6C
                        CONSTANT character_m, 6D
                        CONSTANT character_n, 6E
                        CONSTANT character_o, 6F
                        CONSTANT character_p, 70
                        CONSTANT character_q, 71
                        CONSTANT character_r, 72
                        CONSTANT character_s, 73
                        CONSTANT character_t, 74
                        CONSTANT character_u, 75
                        CONSTANT character_v, 76
                        CONSTANT character_w, 77
                        CONSTANT character_x, 78
                        CONSTANT character_y, 79
                        CONSTANT character_z, 7A
                        CONSTANT character_A, 41
                        CONSTANT character_B, 42
                        CONSTANT character_C, 43
                        CONSTANT character_D, 44
                        CONSTANT character_E, 45
                        CONSTANT character_F, 46
                        CONSTANT character_G, 47
                        CONSTANT character_H, 48
                        CONSTANT character_I, 49
                        CONSTANT character_J, 4A
                        CONSTANT character_K, 4B
                        CONSTANT character_L, 4C
                        CONSTANT character_M, 4D
                        CONSTANT character_N, 4E
                        CONSTANT character_O, 4F
                        CONSTANT character_P, 50
                        CONSTANT character_Q, 51
                        CONSTANT character_R, 52
                        CONSTANT character_S, 53
                        CONSTANT character_T, 54
                        CONSTANT character_U, 55
                        CONSTANT character_V, 56
                        CONSTANT character_W, 57
                        CONSTANT character_X, 58
                        CONSTANT character_Y, 59
                        CONSTANT character_Z, 5A
                        CONSTANT character_0, 30
                        CONSTANT character_1, 31
                        CONSTANT character_2, 32
                        CONSTANT character_3, 33
                        CONSTANT character_4, 34
                        CONSTANT character_5, 35
                        CONSTANT character_6, 36
                        CONSTANT character_7, 37
                        CONSTANT character_8, 38
                        CONSTANT character_9, 39
                        CONSTANT character_colon, 3A
                        CONSTANT character_semi_colon, 3B
                        CONSTANT character_less_than, 3C
                        CONSTANT character_greater_than, 3E
                        CONSTANT character_equals, 3D
                        CONSTANT character_space, 20
                        CONSTANT character_CR, 0D                ;carriage return
                        CONSTANT character_question, 3F          ;'?'
                        CONSTANT character_dollar, 24
                        CONSTANT character_BS, 08                ;Back Space command character
                        ;
                        ;
                        ;
                        ;7-segment display characters
                        ;        bits 0 to 6 = segements A to G
                        ;        bits 7 = decimal point (always off - bit always high)
                        ;Segments are active low
                        ;
                        CONSTANT digit_0, C0
                        CONSTANT digit_1, F9
                        CONSTANT digit_2, A4
                        CONSTANT digit_3, B0
                        CONSTANT digit_4, 99
                        CONSTANT digit_5, 92
                        CONSTANT digit_6, 82
                        CONSTANT digit_7, F8
                        CONSTANT digit_8, 80
                        CONSTANT digit_9, 90
                        CONSTANT digit_A, 88
                        CONSTANT digit_B, 83
                        CONSTANT digit_C, C6
                        CONSTANT digit_D, A1
                        CONSTANT digit_E, 86
                        CONSTANT digit_F, 8E
